import logging
from typing import Dict, Optional, List
import subprocess
import os
import threading
import queue
import re
import concurrent.futures
class ExploitLauncher:
    def __init__(self):
        self.exploit_timeout = 30  # seconds
        self.max_concurrent = 5
        self.exploit_queue = queue.Queue()
        self.results = []
        self.lock = threading.Lock()
        
        # Define available exploits
        self.available_exploits = {
            "heartbleed": {
                "name": "Heartbleed",
                "description": "OpenSSL TLS heartbeat extension vulnerability",
                "ports": [443],
                "script": "exploits/heartbleed.py"
            },
            "shellshock": {
                "name": "Shellshock",
                "description": "Bash vulnerability in CGI scripts",
                "ports": [80, 443],
                "script": "exploits/shellshock.py"
            },
            "dirty_cow": {
                "name": "Dirty COW",
                "description": "Race condition in Linux kernel",
                "ports": [],
                "script": "exploits/dirty_cow.py"
            },
            "poodle": {
                "name": "POODLE",
                "description": "Padding Oracle On Downgraded Legacy Encryption",
                "ports": [443],
                "script": "exploits/poodle.py"
            },
            "eternal_blue": {
                "name": "EternalBlue",
                "description": "SMB vulnerability in Windows",
                "ports": [445],
                "script": "exploits/eternal_blue.py"
            },
            "log4j": {
                "name": "Log4j",
                "description": "Log4j remote code execution vulnerability",
                "ports": [80, 443, 8080],
                "script": "exploits/log4j.py"
            }
        }
        
    def validate_target(self, target: str) -> bool:
        """Validate target format."""
        try:
            # Check if it's an IP address
            parts = target.split('.')
            if len(parts) == 4:
                return all(0 <= int(part) <= 255 for part in parts)
                
            # Check if it's a hostname
            return bool(re.match(r'^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z]{2,})+$', target))
        except:
            return False
            
    def check_exploit_requirements(self, exploit_name: str) -> bool:
        """Check if exploit requirements are met."""
        if exploit_name not in self.available_exploits:
            return False
            
        for requirement in self.available_exploits[exploit_name]['requirements']:
            if not os.path.exists(requirement):
                return False
        return True
        
    def launch_exploit(self, exploit: str, target: str, **kwargs) -> Dict:
        """
        Launch an exploit against a target.
        
        Args:
            exploit: Name of the exploit to launch
            target: Target host
            **kwargs: Additional arguments for the exploit
            
        Returns:
            Dictionary containing exploit results
        """
        try:
            # Validate exploit
            if exploit.lower() not in self.available_exploits:
                return {
                    "error": f"Unknown exploit: {exploit}. Available exploits: {', '.join(self.available_exploits.keys())}"
                }
                
            # Get exploit info
            exploit_info = self.available_exploits[exploit.lower()]
            
            # Check if exploit script exists
            if not os.path.exists(exploit_info["script"]):
                return {"error": f"Exploit script not found: {exploit_info['script']}"}
                
            # Prepare command
            cmd = [
                "python3",
                exploit_info["script"],
                "--target", target
            ]
            
            # Add additional arguments
            for key, value in kwargs.items():
                cmd.extend([f"--{key}", str(value)])
                
            # Launch exploit with timeout
            try:
                process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True
                )
                
                try:
                    stdout, stderr = process.communicate(timeout=self.exploit_timeout)
                    return {
                        "success": process.returncode == 0,
                        "exploit": exploit_info["name"],
                        "target": target,
                        "output": stdout,
                        "error": stderr if stderr else None,
                        "return_code": process.returncode
                    }
                except subprocess.TimeoutExpired:
                    process.kill()
                    return {
                        "error": f"Exploit timed out after {self.exploit_timeout} seconds",
                        "exploit": exploit_info["name"],
                        "target": target
                    }
                    
            except Exception as e:
                return {
                    "error": f"Failed to launch exploit: {str(e)}",
                    "exploit": exploit_info["name"],
                    "target": target
                }
                
        except Exception as e:
            logging.error(f"Error launching exploit: {str(e)}")
            return {"error": f"Exploit failed: {str(e)}"}
            
    def launch_multiple_exploits(self, target: str, exploits: List[str] = None, **kwargs) -> Dict:
        """
        Launch multiple exploits against a target concurrently.
        
        Args:
            target: Target host
            exploits: List of exploits to launch (None for all available)
            **kwargs: Additional arguments for the exploits
            
        Returns:
            Dictionary containing results from all exploits
        """
        try:
            results = {
                "target": target,
                "exploits": [],
                "errors": []
            }
            
            # Use all available exploits if none specified
            if not exploits:
                exploits = list(self.available_exploits.keys())
                
            # Create thread pool
            with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_concurrent) as executor:
                future_to_exploit = {
                    executor.submit(self.launch_exploit, exploit, target, **kwargs): exploit
                    for exploit in exploits
                }
                
                for future in concurrent.futures.as_completed(future_to_exploit):
                    exploit = future_to_exploit[future]
                    try:
                        result = future.result()
                        results["exploits"].append(result)
                    except Exception as e:
                        results["errors"].append(f"Error with {exploit}: {str(e)}")
                        
            return results
            
        except Exception as e:
            logging.error(f"Error launching multiple exploits: {str(e)}")
            return {"error": f"Multiple exploit launch failed: {str(e)}"}
            
    def check_target_vulnerability(self, target: str, exploit: str) -> Dict:
        """
        Check if a target is vulnerable to a specific exploit.
        
        Args:
            target: Target host
            exploit: Exploit to check for
            
        Returns:
            Dictionary containing vulnerability check results
        """
        try:
            if exploit.lower() not in self.available_exploits:
                return {"error": f"Unknown exploit: {exploit}"}
                
            exploit_info = self.available_exploits[exploit.lower()]
            
            # Prepare check command
            cmd = [
                "python3",
                exploit_info["script"],
                "--target", target,
                "--check"
            ]
            
            try:
                process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True
                )
                
                try:
                    stdout, stderr = process.communicate(timeout=10)
                    return {
                        "vulnerable": process.returncode == 0,
                        "exploit": exploit_info["name"],
                        "target": target,
                        "details": stdout,
                        "error": stderr if stderr else None
                    }
                except subprocess.TimeoutExpired:
                    process.kill()
                    return {
                        "error": "Vulnerability check timed out",
                        "exploit": exploit_info["name"],
                        "target": target
                    }
                    
            except Exception as e:
                return {
                    "error": f"Failed to check vulnerability: {str(e)}",
                    "exploit": exploit_info["name"],
                    "target": target
                }
                
        except Exception as e:
            logging.error(f"Error checking vulnerability: {str(e)}")
            return {"error": f"Vulnerability check failed: {str(e)}"}
            
    def get_exploit_info(self, exploit: str = None) -> Dict:
        """
        Get information about available exploits.
        
        Args:
            exploit: Specific exploit to get info for (None for all)
            
        Returns:
            Dictionary containing exploit information
        """
        try:
            if exploit:
                if exploit.lower() not in self.available_exploits:
                    return {"error": f"Unknown exploit: {exploit}"}
                return self.available_exploits[exploit.lower()]
            return self.available_exploits
            
        except Exception as e:
            logging.error(f"Error getting exploit info: {str(e)}")
            return {"error": f"Failed to get exploit info: {str(e)}"}
        
    def list_exploits(self) -> Dict:
        """List available exploits."""
        return {
            "exploits": self.available_exploits,
            "total": len(self.available_exploits)
        }
        
    def add_exploit(self, name: str, description: str, command: str, requirements: list) -> None:
        """Add a new exploit to the launcher."""
        self.available_exploits[name] = {
            'description': description,
            'command': command,
            'requirements': requirements
        }
        
    def remove_exploit(self, name: str) -> bool:
        """Remove an exploit from the launcher."""
        if name in self.available_exploits:
            del self.available_exploits[name]
            return True
        return False 