import logging
from typing import Dict, List
import subprocess
import os
import threading
import queue
import re
import concurrent.futures
import sys
import platform


class ExploitLauncher:
    def __init__(self):
        self.exploit_timeout = 30  # seconds
        self.max_concurrent = 5
        self.exploit_queue = queue.Queue()
        self.results = []
        self.lock = threading.Lock()

        self.available_exploits = {
            "heartbleed": {
                "name": "Heartbleed",
                "description": "OpenSSL TLS heartbeat extension vulnerability",
                "ports": [443],
                "script": "exploits/heartbleed.py",
            },
            "shellshock": {
                "name": "Shellshock",
                "description": "Bash vulnerability in CGI scripts",
                "ports": [80, 443],
                "script": "exploits/shellshock.py",
            },
            "dirty_cow": {
                "name": "Dirty COW",
                "description": "Race condition in Linux kernel",
                "ports": [],
                "script": "exploits/dirty_cow.py",
            },
            "poodle": {
                "name": "POODLE",
                "description": "Padding Oracle On Downgraded Legacy Encryption",
                "ports": [443],
                "script": "exploits/poodle.py",
            },
            "eternal_blue": {
                "name": "EternalBlue",
                "description": "SMB vulnerability in Windows",
                "ports": [445],
                "script": "exploits/eternal_blue.py",
            },
            "log4j": {
                "name": "Log4j",
                "description": "Log4j remote code execution vulnerability",
                "ports": [80, 443, 8080],
                "script": "exploits/log4j.py",
            },
        }

    def validate_target(self, target: str) -> bool:
        """Validate target format."""
        try:
            parts = target.split(".")
            if len(parts) == 4:
                return all(0 <= int(part) <= 255 for part in parts)

            return bool(
                re.match(
                    r"^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z]{2,})+$",
                    target,
                )
            )
        except:
            return False

    def check_exploit_requirements(self, exploit_name: str) -> bool:
        if exploit_name not in self.available_exploits:
            return False

        for requirement in self.available_exploits[exploit_name]["requirements"]:
            if not os.path.exists(requirement):
                return False
        return True

    def launch_exploit(self, exploit: str, target: str, **kwargs) -> Dict:
        try:
            if exploit.lower() not in self.available_exploits:
                return {
                    "error": f"Unknown exploit: {exploit}. Available exploits: {', '.join(self.available_exploits.keys())}"
                }

            exploit_info = self.available_exploits[exploit.lower()]

            if not os.path.exists(exploit_info["script"]):
                return {"error": f"Exploit script not found: {exploit_info['script']}"}

            # Get the Python executable path
            python_path = (
                sys.executable
            )  # This gets the current Python interpreter path

            # Build the command with the full Python path
            cmd = [python_path, exploit_info["script"], "--target", target]
            for key, value in kwargs.items():
                cmd.extend([f"--{key}", str(value)])

            try:
                # Use shell=True on Windows to handle Python path issues
                use_shell = platform.system() == "Windows"

                process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    shell=use_shell,
                )

                try:
                    stdout, stderr = process.communicate(timeout=self.exploit_timeout)
                    return {
                        "success": process.returncode == 0,
                        "exploit": exploit_info["name"],
                        "target": target,
                        "output": stdout,
                        "error": stderr if stderr else None,
                        "return_code": process.returncode,
                    }
                except subprocess.TimeoutExpired:
                    process.kill()
                    return {
                        "error": f"Exploit timed out after {self.exploit_timeout} seconds",
                        "exploit": exploit_info["name"],
                        "target": target,
                    }

            except Exception as e:
                return {
                    "error": f"Failed to launch exploit: {str(e)}",
                    "exploit": exploit_info["name"],
                    "target": target,
                }

        except Exception as e:
            logging.error(f"Error launching exploit: {str(e)}")
            return {"error": f"Exploit failed: {str(e)}"}

    def launch_multiple_exploits(
        self, target: str, exploits: List[str] = None, **kwargs
    ) -> Dict:

        try:
            results = {"target": target, "exploits": [], "errors": []}

            if not exploits:
                exploits = list(self.available_exploits.keys())

            with concurrent.futures.ThreadPoolExecutor(
                max_workers=self.max_concurrent
            ) as executor:
                future_to_exploit = {
                    executor.submit(
                        self.launch_exploit, exploit, target, **kwargs
                    ): exploit
                    for exploit in exploits
                }

                for future in concurrent.futures.as_completed(future_to_exploit):
                    exploit = future_to_exploit[future]
                    try:
                        result = future.result()
                        results["exploits"].append(result)
                    except Exception as e:
                        results["errors"].append(f"Error with {exploit}: {str(e)}")

            return results

        except Exception as e:
            logging.error(f"Error launching multiple exploits: {str(e)}")
            return {"error": f"Multiple exploit launch failed: {str(e)}"}

    def check_target_vulnerability(self, target: str, exploit: str) -> Dict:
        try:
            if exploit.lower() not in self.available_exploits:
                return {"error": f"Unknown exploit: {exploit}"}

            exploit_info = self.available_exploits[exploit.lower()]

            cmd = ["python3", exploit_info["script"], "--target", target, "--check"]

            try:
                process = subprocess.Popen(
                    cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
                )

                try:
                    stdout, stderr = process.communicate(timeout=10)
                    return {
                        "vulnerable": process.returncode == 0,
                        "exploit": exploit_info["name"],
                        "target": target,
                        "details": stdout,
                        "error": stderr if stderr else None,
                    }
                except subprocess.TimeoutExpired:
                    process.kill()
                    return {
                        "error": "Vulnerability check timed out",
                        "exploit": exploit_info["name"],
                        "target": target,
                    }

            except Exception as e:
                return {
                    "error": f"Failed to check vulnerability: {str(e)}",
                    "exploit": exploit_info["name"],
                    "target": target,
                }

        except Exception as e:
            logging.error(f"Error checking vulnerability: {str(e)}")
            return {"error": f"Vulnerability check failed: {str(e)}"}

    def get_exploit_info(self, exploit: str = None) -> Dict:
        try:
            if exploit:
                if exploit.lower() not in self.available_exploits:
                    return {"error": f"Unknown exploit: {exploit}"}
                return self.available_exploits[exploit.lower()]
            return self.available_exploits

        except Exception as e:
            logging.error(f"Error getting exploit info: {str(e)}")
            return {"error": f"Failed to get exploit info: {str(e)}"}

    def list_exploits(self) -> Dict:
        return {
            "exploits": self.available_exploits,
            "total": len(self.available_exploits),
        }

    def add_exploit(
        self, name: str, description: str, command: str, requirements: list
    ) -> None:
        self.available_exploits[name] = {
            "description": description,
            "command": command,
            "requirements": requirements,
        }

    def remove_exploit(self, name: str) -> bool:
        if name in self.available_exploits:
            del self.available_exploits[name]
            return True
        return False
